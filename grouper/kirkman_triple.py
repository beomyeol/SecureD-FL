"""Kirkman triple group generator."""
# pylint: disable=invalid-name
import random
import time

import networkx as nx


def is_clique(G, vert):
    """Returns whether the induced subgraph by vert creates a clique in G."""
    size = len(vert)
    for i in range(size):
        for j in range(i+1, size, 1):
            if not G.has_edge(vert[i], vert[j]):
                return False
    return True


def delete_clique(G, vert):
    """Deletes a clique generated by the vertices of vert."""
    size = len(vert)
    for i in range(size):
        for j in range(i+1, size, 1):
            G.remove_edge(vert[i], vert[j])


def add_clique(G, vert):
    """Adds a clique to the graph."""
    size = len(vert)
    for i in range(size):
        for j in range(i+1, size, 1):
            G.add_edge(vert[i], vert[j])


def rollback(G, S):
    """Rolls back by adding the permutations.

    If we get stuck in a partial partition, its better to roll back.
    """
    for s in S:
        add_clique(G, s)


def find_kirkman_triples(n, num_trials=1000000, allowed_fail_count=1000):
    """Finds kirkman triples via the randomized method.

    Args:
        n: the number of participants. n mod 6 must be 3.
        num_trials: the number of trials.
        allowed_fail_count: unsuccessful trial threshold to roll back.
    """
    if n % 6 != 3:
        raise ValueError("n mod 6 must be 3. n=%d" % n)
    m = n // 6
    bound = 3 * m + 1
    fail_count = 0

    S = []  # solutions
    s = []  # a single solution
    G = nx.complete_graph(n)
    U = set(G.nodes)

    for _ in range(num_trials):
        # randomly sample withour replacement from U
        vert = random.sample(U, 3)
        if is_clique(G, vert):
            # successful trial
            fail_count = 0
            U -= set(vert)
            # delete the edges of the clique
            # so that it cannot appear in next permutations
            delete_clique(G, vert)
            # append in the partial permutation
            s.append(vert)
            if len(s) == n/3:
                # we got a full permutation.
                S.append(s)
                if len(S) == bound:
                    # no more possible solution.
                    break

                s = []
                U = set(G.nodes)
        else:
            # unsuccessful trial
            fail_count += 1
            # too many unsuccessful trials
            # so roll back and abort the partial permutation
            if fail_count == allowed_fail_count:
                fail_count = 0
                U = set(G.nodes)
                rollback(G, s)
                s = []
    return S


if __name__ == "__main__":
    # number of times we want to run for a particular n
    num_tests = 1
    # the start m
    start = 1
    # the end m
    end = 3

    # looping for each m
    for m in range(start, end):
        n = 6 * m + 3
        # for averaging the number of permutation accross different test
        totcount = 0

        start = time.time()
        for test in range(num_tests):
            # the universe is the set U={1,2,...,n}
            S = find_kirkman_triples(n)
            totcount = totcount + len(S)
        end = time.time()

        log = []
        log.append(str(m))
        log.append(str(n))
        log.append(str(3*m+1))  # theoretical bound on # permutations
        log.append(str(float(totcount)/num_tests))  # average # permutations
        log.append(str((end-start)/num_tests))  # average runtimes
        print(', '.join(log))
